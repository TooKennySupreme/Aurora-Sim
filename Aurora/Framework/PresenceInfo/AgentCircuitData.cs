/*
 * Copyright (c) Contributors, http://aurora-sim.org/, http://opensimulator.org/
 * See CONTRIBUTORS.TXT for a full list of copyright holders.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Aurora-Sim Project nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using OpenMetaverse;
using OpenMetaverse.StructuredData;

namespace Aurora.Framework
{
    /// <summary>
    ///   Circuit data for an agent.  Connection information shared between
    ///   regions that accept UDP connections from a client
    /// </summary>
    public class AgentCircuitData : IDataTransferable
    {
        #region Variables

        /// <summary>
        ///   Avatar Unique Agent Identifier
        /// </summary>
        public UUID AgentID;

        /// <summary>
        ///   Avatar's Appearance
        /// </summary>
        public AvatarAppearance Appearance;

        /// <summary>
        ///   Base Caps path for user
        /// </summary>
        public string CapsPath = String.Empty;

        /// <summary>
        ///   IntenalUseOnly - Kept by the server to tell where the client originated from
        /// </summary>
        public IPEndPoint ClientIPEndPoint;

        /// <summary>
        ///   Draw Distance (set by the root agent)
        /// </summary>
        public float DrawDistance;

        /// <summary>
        ///   The client's IP address, as captured by the login service
        /// </summary>
        public string IPAddress;

        /// <summary>
        ///   Other unknown info
        /// </summary>
        public OSDMap OtherInformation = new OSDMap();

        /// <summary>
        ///   IntenalUseOnly - Kept by the server to tell the rest of the server what port to call the region on
        /// </summary>
        public int RegionUDPPort;

        /// <summary>
        ///   Random Unique GUID for this session.  Client gets this at login and it's
        ///   only supposed to be disclosed over secure channels
        /// </summary>
        public UUID SecureSessionID;

        /// <summary>
        ///   Hypergrid service token; generated by the user domain, consumed by the receiving grid.
        ///   There is one such unique token for each grid visited.
        /// </summary>
        public string ServiceSessionID = string.Empty;

        //HG info...
        public Dictionary<string, object> ServiceURLs;

        /// <summary>
        ///   Non secure Session ID
        /// </summary>
        public UUID SessionID;

        /// <summary>
        ///   Root agent, or Child agent, check realischild if you want to know though, this can be wrong
        /// </summary>
        public bool child;

        /// <summary>
        ///   The region handle of the region the root agent is in
        /// </summary>
        public ulong roothandle;

        /// <summary>
        ///   Number given to the client when they log-in that they provide 
        ///   as credentials to the UDP server
        /// </summary>
        public uint circuitcode;

        /// <summary>
        ///   Agent's account first name OPENSIM
        /// </summary>
        public string firstname;

        /// <summary>
        ///   Agent's account last name OPENSIM
        /// </summary>
        public string lastname;

        /// <summary>
        ///   The real child boolean, OpenSim always sends false, so we read this for Aurora regions
        /// </summary>
        public bool reallyischild;

        /// <summary>
        ///   Position the Agent's Avatar starts in the region
        /// </summary>
        public Vector3 startpos;

        /// <summary>
        ///   How this agent got here
        /// </summary>
        public uint teleportFlags;

        #endregion

        #region IDataTransferable

        /// <summary>
        ///   Serialize the module to OSD
        /// </summary>
        /// <returns></returns>
        public override OSDMap ToOSD()
        {
            return PackAgentCircuitData();
        }

        /// <summary>
        ///   Deserialize the module from OSD
        /// </summary>
        /// <param name = "map"></param>
        public override void FromOSD(OSDMap map)
        {
            UnpackAgentCircuitData(map);
        }

        #region oldFunctions

        /// <summary>
        ///   Pack AgentCircuitData into an OSDMap for transmission over LLSD XML or LLSD json
        /// </summary>
        /// <returns>map of the agent circuit data</returns>
        public virtual OSDMap PackAgentCircuitData()
        {
            OSDMap args = new OSDMap();
            args["agent_id"] = OSD.FromUUID(AgentID);
            args["caps_path"] = OSD.FromString(CapsPath);
            args["child"] = OSD.FromBoolean(child);
            args["roothandle"] = OSD.FromULong(roothandle);
            args["reallyischild"] = OSD.FromBoolean(reallyischild);
            args["circuit_code"] = OSD.FromString(circuitcode.ToString());
            args["secure_session_id"] = OSD.FromUUID(SecureSessionID);
            args["session_id"] = OSD.FromUUID(SessionID);

            args["service_session_id"] = OSD.FromString(ServiceSessionID);
            args["start_pos"] = OSD.FromString(startpos.ToString());
            args["client_ip"] = OSD.FromString(IPAddress);
            args["otherInfo"] = OSDParser.SerializeLLSDXmlString(OtherInformation);
            args["teleport_flags"] = OSD.FromUInteger(teleportFlags);
            args["first_name"] = OSD.FromString(firstname);
            args["last_name"] = OSD.FromString(lastname);
            args["draw_distance"] = DrawDistance;
            args["RegionUDPPort"] = RegionUDPPort;

            if (Appearance != null)
            {
                args["appearance_serial"] = OSD.FromInteger(Appearance.Serial);

                OSDMap appmap = Appearance.Pack();
                args["packed_appearance"] = appmap;
            }
            else
                MainConsole.Instance.Error("[AgentCircuitData]: NOT PACKING APPEARANCE FOR " + firstname + " " + lastname +
                            ", user may be messed up");

            if (ServiceURLs != null && ServiceURLs.Count > 0)
            {
                OSDMap urls = new OSDMap();
                foreach (KeyValuePair<string, object> kvp in ServiceURLs)
                {
                    //System.Console.WriteLine("XXX " + kvp.Key + "=" + kvp.Value);
                    urls[kvp.Key] = OSD.FromString((kvp.Value == null) ? string.Empty : kvp.Value.ToString());
                }
                args["serviceurls"] = urls;
            }

            return args;
        }

        public virtual AgentCircuitData Copy()
        {
            AgentCircuitData Copy = new AgentCircuitData
            {
                AgentID = AgentID,
                Appearance = Appearance,
                CapsPath = CapsPath,
                child = child,
                reallyischild = reallyischild,
                circuitcode = circuitcode,
                IPAddress = IPAddress,
                SecureSessionID = SecureSessionID,
                SessionID = SessionID,
                startpos = startpos,
                teleportFlags = teleportFlags,
                OtherInformation = OtherInformation,
                ServiceURLs = ServiceURLs,
                firstname = firstname,
                lastname = lastname,
                DrawDistance = DrawDistance
            };


            return Copy;
        }

        /// <summary>
        ///   Unpack agent circuit data map into an AgentCiruitData object
        /// </summary>
        /// <param name = "args"></param>
        public virtual void UnpackAgentCircuitData(OSDMap args)
        {
            if (args["agent_id"] != null)
                AgentID = args["agent_id"].AsUUID();
            if (args["caps_path"] != null)
                CapsPath = args["caps_path"].AsString();
            if (args["reallyischild"] != null)
                reallyischild = args["reallyischild"].AsBoolean();
            if (args["child"] != null)
                child = args["child"].AsBoolean();
            if (args["roothandle"] != null)
                roothandle = args["roothandle"].AsULong();
            if (args["circuit_code"] != null)
                UInt32.TryParse(args["circuit_code"].AsString(), out circuitcode);
            if (args["secure_session_id"] != null)
                SecureSessionID = args["secure_session_id"].AsUUID();
            if (args["session_id"] != null)
                SessionID = args["session_id"].AsUUID();
            if (args["service_session_id"] != null)
                ServiceSessionID = args["service_session_id"].AsString();
            if (args["client_ip"] != null)
                IPAddress = args["client_ip"].AsString();
            if (args["first_name"] != null)
                firstname = args["first_name"].AsString();
            if (args["last_name"] != null)
                lastname = args["last_name"].AsString();
            if (args["RegionUDPPort"] != null)
                RegionUDPPort = args["RegionUDPPort"];

            if (args["start_pos"] != null)
                Vector3.TryParse(args["start_pos"].AsString(), out startpos);

            if (args["teleport_flags"] != null)
                teleportFlags = args["teleport_flags"].AsUInteger();
            if (args["draw_distance"] != null)
                DrawDistance = args["draw_distance"];

            // DEBUG ON
            //MainConsole.Instance.WarnFormat("[AGENTCIRCUITDATA] agentid={0}, child={1}, startpos={2}", AgentID, child, startpos.ToString());
            // DEBUG OFF

            try
            {
                // Unpack various appearance elements
                Appearance = new AvatarAppearance(AgentID);

                // Eventually this code should be deprecated, use full appearance
                // packing in packed_appearance
                if (args["appearance_serial"] != null)
                    Appearance.Serial = args["appearance_serial"].AsInteger();

                if (args.ContainsKey("packed_appearance") && (args["packed_appearance"].Type == OSDType.Map))
                {
                    Appearance.Unpack((OSDMap)args["packed_appearance"]);
                    // DEBUG ON
                    //MainConsole.Instance.WarnFormat("[AGENTCIRCUITDATA] unpacked appearance");
                    // DEBUG OFF
                }
                // DEBUG ON
                else
                    MainConsole.Instance.Warn("[AGENTCIRCUITDATA] failed to find a valid packed_appearance, dne ? " +
                               !args.ContainsKey("packed_appearance"));
                // DEBUG OFF
            }
            catch (Exception e)
            {
                MainConsole.Instance.ErrorFormat("[AGENTCIRCUITDATA] failed to unpack appearance; {0}", e);
            }

            if (args.ContainsKey("otherInfo"))
                OtherInformation = (OSDMap)OSDParser.DeserializeLLSDXml(args["otherInfo"].AsString());

            ServiceURLs = new Dictionary<string, object>();
            // Try parse the new way, OSDMap
            if (args.ContainsKey("serviceurls") && args["serviceurls"] != null &&
                (args["serviceurls"]).Type == OSDType.Map)
            {
                OSDMap urls = (OSDMap)(args["serviceurls"]);
                foreach (KeyValuePair<String, OSD> kvp in urls)
                {
                    ServiceURLs[kvp.Key] = kvp.Value.AsString();
                    //System.Console.WriteLine("XXX " + kvp.Key + "=" + ServiceURLs[kvp.Key]);
                }
            }
        }

        #endregion

        #endregion

    }
}